<!-- 
    1.  JavaScript can be executed inside the browser's console, using the Node.js runtime environment or inside <script> tags of an HTML document.

    2.  var a = 7   => variable declaration: keyword (var) identifier (a) assignment (=) operator literal (7)

    3.  'var' is globally scoped while 'let' & 'const' are block scoped.
        'var' can be updated and redeclared within its scope, 'let' can be updated but not redeclared while 'const' can neither be updated nor redeclared.
        'var' is initialised as undefined whereas 'let' & 'const' are not initialised (throw reference error if accessed before declaring).
        'const' must be assigned a value during declaration. 

    4.  Primitive Datatypes => NULL, NUMBER, SYMBOL, STRING, BOOLEAN, BIGINT, UNDEFINED

    6.  Arithmetic operators: +, -, *, /, ** (exponent), % (mod), ++ (increment), -- (decrement).
        Assignment operators: =, +=, -=, *=, /=, %=, **=.
        Comparison operator: ==, !=, ===, !==, >, <, >=, <=, ? (ternary operator)
        Logical operator: && (and), || (or), ! (not)

    7.  Pop-Up boxes    => Alert, Confirm, Prompt   // These depend on browser and can't be modified.
        parseInt and parseFloat used to convert value to number

    9.  Types of loops  => For, For-In (run through keys of an object or array), For-Of (iterates through values of arrays or strings), While, Do-While

    11. Functions allow separation of logic and use DRY principle

    13. Template Literals use backtics{`} and allow single/double quotes inside, they also allow variables inside using String Interpolation.
        Escape Sequence is used to write special characters in a string, eg. \', \", \n, \t, \r

    14. String properties and methods   => length, toUpperCase, toLowerCase, slice(start, end), replace(og_str, new_str), concat, trim, includes(part_of_string), startsWith(), endsWith()

    16. Arrays are mutable but strings are immutable

    17. Array properties and methods   => toString, join(separator), pop, push, shift, unshift, concat, splice, slice(start, end), reverse,
    delete - leaves empty space,
    sort - alphabetical; add a function to change comparison method

    19. forEach()   => runs a function for each array item
        Array.from()    => create array from any other object type, eg. strings, objects, HTML collection

    20. map()   =>  runs a function for each array element and returns a new array
        filter()    => filters array with values that pass a test and returns a new array
        reduce(sum, current, index, array)    => executes a reducer function on an array and returns a single value

    23. Chrome Dev Tools:
            Elements- shows all HTML elements,
            Console- shows all JS warnings n errors,
            Network- shows all sent requests,
            Lighthouse- shows improvements to be made

    24. Advantages of using separate script files:  separation of concerns, browser caching

    25. Console object methods: assert, clear, log, table, warn, error, info, time, dir (shows HTML element as DOM object)

    28. 'window' (represents browser window) is a global object which provides multiple methods to control it.
    Document Object Model aka DOM is the HTML page represented as a JS object.
    Browser Object Model aka BOM is the object representation of the host environment, pop-up boxes are part of BOM

    32. 'childNodes' is a collection, use Array.from() to convert it into an array.

    33. '$0' refers to the selected element in the console.
        Node in DOM can mean anything- comment, blank space etc while Element mean a particular HTML tag

    36. Types of DOM selectors- getElementById, getElementByClassName, getElementByTagname, querySelector, querySelectorAll, getElementsByName (using 'name' attribute)

    41. 'innerHTML' returns content inside given selector, 'outerHTML' returns opening-closing tags as well as content inside.
        'innerText' only extracts user readable content, whereas 'textContent' can even get <script> n <style> data

    42. Attribute methods:  hasAttribute, getAttribute, setAttribute, removeAttribute, attributes

    43. Insertion methods:  innerHTML, createElement, append, prepend, before, after, replaceWith

    44. insertAdjacent HTML/element/text method drops code in a specified position, some properties of this method are: beforebegin, afterbegin, beforeend, afterend.
        Use 'remove()' method to delete HTML elements

    45. DOM has some class related methods: classList.add/remove/toggle/contains("class")

    46. 'setTimeOut' runs a function after some interval    => setTimeOut(function_name, delay, args).
        'setInterval' runs a function repeatedly at given time gap.
        'clearTimeOut' and 'clearInterval' cancel execution of above methods

    47. Types of browser events:
            - Mouse Events  => click, dblclick, mouseover
            - Keyboard Events   => keyup, keydown, keypress
            - Form Events   => submit, focus, change
            - Window Events => resize, load, unload

    48. 'addEventListener' can assign one or more handlers to an event.
        'removeEventListener' must refer to the same function-object for it to work.
        When an event occurs, the browser creates an 'Event Object' and passes it as the handler's argument with all details- type, target, clientX, clientY etc
        JavaScript handler overwrites HTML attribute handler

    74. OOPS allow us to create specific objects using pre-defined set of classes.
        Main features of OOPS:  Encapsulation, Abstraction, Inheritance and Polymorphism

    75. Objects have special property called Prototype which is either null or refers to another object.
        We can set custom prototype using __proto__, so if we call a method not present in the object it can look for in the prototype

    76. Class works like a template for indevidual objects, 'this' keyword refers to the current object

    77. Constructor() method is called automatially by the 'new' keyword whenever an object is initialised

    78. 'extends' keyword is used by a class to inherit methods and properties of another class (they then become parent n child)

    79. We can override methods from the extended class in the child class, it's called Method Overriding.
        We can call the original method in parent class even if it's been overridden using the 'super' keyword

    80. If a class extends another class and doesn't have a constructor, an empty one is generated automatically.
        Constructors in an inherited class must call super() and do so before using 'this'

    81. Static Methods are functions that belong to a class as a whole and not any particular object.
        To call a static method use class_name.method() and not object_name.method()

    82. 'instanceof' operator checks whether an object belongs to a certain class (or any class it's inherited from)
        **Getter and Setter remain**

    87. Destructuring is used to unpack values from an array or properties from an object
            eg. [x, y, , , ...rest] = [1, 2, 3, 4, 5, 6, 7, 8, 9] =>  x=1; y=2; rest=[5,6,7,8,9]
            eg. {prop1, prop2, prop3} = obj_name  OR  {prop1:var1, prop2:var2, prop3:var3} = obj_name
        SPREAD operator allows expressions to be expanded in places where multiple arguments are expected
            eg. [1, 2, 3, ...arr1] = [1,2,3,4,5,6]
            eg. const fun = (a,b,c)=>a+b+c;  fun(...arr1)




******************************************************************************************************************************
** CALLBACKS, PROMISES, ASYNC-AWAIT, ERROR HANDLING, FETCH, COOKIES, LOCAL STORAGE, SESSION STORAGE, IIFE, HOISTING, CLOSURE, EVENT LOOP **
******************************************************************************************************************************

    52. Synchronous actions take initiate and finish one by one, while Asychronous actions initiate immidiately but finish at a later time.
        When a function is passed onto another function as an argument its called a 'Callback' function.
        If a function works asynchronously, it must provide a callback argument which will run after its completion

    53. When we have callbacks inside callbacks and the nested code grows, it becomes difficult to read and manage, this is called 'Callback Hell' or 'Pyramid of Doom'. We can solve this using 'Promises'

    54. Promises are used to run different commands parallely (asynchronously) ie. multi-tasking, not waiting idle.
            let x = new Promise( (resolve, reject) => {
              ...
            });
        The returned object has two properties:
          State-  which can be pending or fulfilled
          Result- initially pending then changes to a value either Resolve(value) or Reject(error)

    55. The value returned by Promise is received using 'then' and 'catch'

    56. We can link promises where they can pass values to one another, this is called 'Promise Chaining' and solves the problem of Callback Hell / Pyramid of Doom

    57. We can also have multiple handlers (.then / .catch methods) separate from one another but linked to a single Promise

    58. Promise class provides the following methods -  Promise.all, Promise.allSettled, Promise.race, Promise.any, Promise.resolve, Promise.reject

    59. We can turn any function as 'async' with 'await' Promises inside

    60. 'Try...Catch' syntax allows script to run instead of dying due to an error

    61. We can generate custom errors using the 'throw' keyword.
        Errors have their own properties: name, message & stack

    62. Try...Catch construct may have another clause called 'finally' which runs in all cases (even if there's a return statement in try block)
 -->

<!-- PRACTICE SETS -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- 
    <nav>
      <ul>
        <li>I</li>
        <li><3</li>
        <li>U</li>
      </ul>
    </nav>
     -->

    <!-- 
    <table>
      <thead>
        <tr>
          <th>jvkjv</th>
        </tr>
      </thead>
      <tr>
        <td>jhvbjd</td>
      </tr>
    </table>
     -->

    <!-- 
    <div>
      <button>Click Me!</button>
      <button>Add bookmark</button>
      <button class="off" style="background-color: #000; color: yellow">
        Light Bulb!
      </button>
    </div>
     -->

    <div id="clock">CLOCK</div>

    <script>
      /*
       const rand = Math.floor(Math.random() * 100);
       let ip;
       let count = 0;
       do {
         count++;
         ip = parseInt(prompt("input"));
         if (ip > rand) console.log("lower");
         else if (ip < rand) console.log("higher");
         else {
           console.log("correct");
           break;
         }
       } while (count < 100);
       console.log("SCORE: " + (100 - count));
       */

      /*
       let age, check;
       do {
         age = Number.parseInt(prompt("ENTER YOUR AGE: "));
         if (age < 0) console.error("ARE YOU A GHOST?!");
         else {
           if (age < 18) alert("YOU'RE NOT ALLOWED TO DRIVE..");
           else alert("YOU'RE ALLOWED TO DRIVE..");
           check = confirm("WOULD YOU LIKE TO CHECK AGAIN?");
         }
       } while (check == true);
       */

      /*
      let rand = () => {
        return Math.floor(Math.random() * 10);
      };
      let num = Number.parseInt(prompt("ENTER"));
      if (num > 4) location.href = "https://google.com/";
      else document.body.style.backgroundColor = `#${rand()}${rand()}${rand()}`;
      */

      /*
      let user = prompt("choose from 'S', 'W', or 'G'");
      let rand = Math.ceil(Math.random() * 3);
      if (user == "S") {
        if (rand == 1) console.log("Computer chose Snake as well, it's a Tie");
        else if (rand == 2) console.log("Computer chose Water, You Win!");
        else console.log("Computer chose Gun, You Lose!");
      }
      if (user == "W") {
        if (rand == 1) console.log("Computer chose Snake, You Lose!");
        else if (rand == 2)
          console.log("Computer chose Water as well, it's a Tie");
        else console.log("Computer chose Gun, You Win!");
      }
      if (user == "G") {
        if (rand == 1) console.log("Computer chose Snake, You Win!");
        else if (rand == 2) console.log("Computer chose Water, You Lose!");
        else console.log("Computer chose Gun as well, it's a Tie");
      }
      */

      /*
      document.getElementsByTagName("nav")[0].firstElementChild.style.color =
        "red";

      document.getElementsByTagName("div")[0].firstElementChild.style.color =
        "green";
      document.getElementsByTagName("div")[0].lastElementChild.style.color =
        "green";
      let z = document.getElementsByTagName("li");
      for (let i of z) i.style.backgroundColor = "cyan";
      */

      /*
      const jokes = [
        "Tom",
        "Dick",
        "Harry",
        "Motu",
        "Patlu",
        "Banti",
        "Billa",
        "Babban",
        "Oggy",
        "Cockroaches",
      ];
      const rand = Math.floor(Math.random() * 10);
      document.getElementsByTagName("div")[0].innerHTML = jokes[rand];
      */

      /*
      let btn1 = Array.from(document.querySelectorAll("div button"));
      btn1[0].addEventListener("click", function () {
        alert("Hello 1!");
      });
      btn1[1].addEventListener("click", function () {
        let bookmark = prompt("Submit link to save");
        let addLine = document.createElement("p");
        addLine.innerText = bookmark;
        document.body.appendChild(addLine);
      });
      btn1[2].addEventListener("click", function (e) {
        let toggler = btn1[2].getAttribute("class");
        if (toggler == "off") {
          btn1[2].setAttribute("class", "on");
          btn1[2].style.backgroundColor = "yellow";
          btn1[2].style.color = "#000";
        } else {
          btn1[2].setAttribute("class", "off");
          btn1[2].style.backgroundColor = "#000";
          btn1[2].style.color = "yellow";
        }
      });
      */

      /*
      setInterval(function () {
        const current = new Date();
        const hrs = current.getHours();
        const min = current.getMinutes();
        const sec = current.getSeconds();
        let pick = document.querySelector("#clock");
        pick.innerHTML = `${hrs}:${min}:${sec}`;
      }, 1000);
      */

      class Complex {
        constructor(num) {
          let real = num % 1;
          let unreal = num - real;
        }
        add(x, y) {
          return x + y;
        }
      }

      class Human {
        talk() {
          console.log("HE CAN TALK");
        }
      }
      class Student extends Human {
        talk() {
          console.log("HE CAN'T TALK..!!");
        }
      }
      let a = new Student();
      a.talk();
      console.log(a instanceof Human);
    </script>
  </body>
</html>
